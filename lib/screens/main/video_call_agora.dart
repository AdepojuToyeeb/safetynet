import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:geolocator/geolocator.dart';
import 'package:safetynet/utils/snack_message.dart';

const appId = "";
const token =
    "";
const channel = "";

String generateRoomId() {
  final random = Random();
  String roomId = '';

  // Generate 4 random digits
  for (var i = 0; i < 6; i++) {
    roomId += random.nextInt(10).toString();
  }

  return roomId;
}

// Application class
class AgoraCall extends StatefulWidget {
  const AgoraCall({super.key});

  @override
  AgoraCallState createState() => AgoraCallState();
}

// Application state class
class AgoraCallState extends State<AgoraCall> {
  late RtcEngine _engine; // The RtcEngine instances
  Position? _currentPosition; //current location where stream was initiated
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  bool error = false;
  bool _initStatusLoading = true;
  String roomId = generateRoomId();
  bool _isMuted = false;
  bool _isVideoEnabled = true;
  bool _isFrontCamera = true;

  @override
  void initState() {
    super.initState();
    initAgora();
  }

  Future<void> initAgora() async {
    // Get microphone and camera permissions
    await [Permission.microphone, Permission.camera].request();
    _getCurrentLocation();
    // Create RtcEngine instance
    _engine = await createAgoraRtcEngine();

    // Initialize RtcEngine and set the channel profile to live broadcasting
    await _engine.initialize(const RtcEngineContext(
      appId: appId,
      channelProfile: ChannelProfileType.channelProfileCommunication,
    ));

    // Add an event handler
    _engine.registerEventHandler(
      RtcEngineEventHandler(
        // Occurs when the local user joins the channel successfully
        onJoinChannelSuccess: (RtcConnection connection, int elapsed) {
          setState(() {
            _initStatusLoading = false;
          });
        },
        // Occurs when a remote user join the channel
        onUserJoined: (RtcConnection connection, int remoteUid, int elapsed) {
        },
        // Occurs when a remote user leaves the channel
        onUserOffline: (RtcConnection connection, int remoteUid,
            UserOfflineReasonType reason) {
        },
      ),
    );
    // Enable the video module
    await _engine.enableVideo();
    // Enable local video preview
    await _engine.startPreview();
    // Join a channel using a temporary token and channel name
    await _engine.joinChannel(
      token: token,
      channelId: channel,
      options: const ChannelMediaOptions(
          // Automatically subscribe to all video streams
          autoSubscribeVideo: true,
          // Automatically subscribe to all audio streams
          autoSubscribeAudio: true,
          // Publish camera video
          publishCameraTrack: true,
          // Publish microphone audio
          publishMicrophoneTrack: true,
          // Set user role to clientRoleBroadcaster (broadcaster) or clientRoleAudience (audience)
          clientRoleType: ClientRoleType.clientRoleBroadcaster,
          audienceLatencyLevel:
              AudienceLatencyLevelType.audienceLatencyLevelLowLatency),
      uid:
          0, // When you set uid to 0, a user name is randomly generated by the engine
    );
  }

  Future<void> _getCurrentLocation() async {
    try {
      // Check location permissions
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          SnackMsg.showError(context, 'Location permissions are denied');
          return;
        }
      }

      // Get current position
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
      );
      setState(() => _currentPosition = position);

      // Save room data to Firebase
      await _saveRoomToFirebase();
    } catch (e) {
      SnackMsg.showError(context, 'Error getting location: $e');
    }
  }

  Future<void> _saveRoomToFirebase() async {
    if (_currentPosition != null) {
      try {
        await _firestore.collection('room').doc(roomId).set({
          'roomId': roomId,
          'createdAt': FieldValue.serverTimestamp(),
          'location': GeoPoint(
            _currentPosition!.latitude,
            _currentPosition!.longitude,
          ),
          'userId': "",
          'channel': channel,
          'active': true,
        });
        setState(() {
          _initStatusLoading = false;
        });
      } catch (e) {
        SnackMsg.showError(context, 'Error saving room data: $e');
      }
    }
  }

  void _onToggleMute() {
    setState(() {
      _isMuted = !_isMuted;
    });
    _engine.disableAudio();
  }

  void _onToggleShowMute() {
    setState(() {
      _isMuted = !_isMuted;
    });
    _engine.enableAudio();
  }

  void _onToggleVideo() {
    setState(() {
      _isVideoEnabled = !_isVideoEnabled;
    });
    _engine.disableVideo();
  }

  void _onToggleShowVideo() {
    setState(() {
      _isVideoEnabled = !_isVideoEnabled;
    });
    _engine.enableVideo();
  }

  Future<void> _onEndCall() async {
    try {
      // Update room status in Firebase
      await _firestore.collection('room').doc(roomId).update({
        'active': false,
        'endedAt': FieldValue.serverTimestamp(),
      });

      // Leave the channel and clean up
      await _engine.leaveChannel();
      await _engine.release();

      // Pop the current route if the context is still mounted
      if (mounted) {
        Navigator.of(context).pop();
      }
    } catch (e) {
      if (mounted) {
        SnackMsg.showError(context, 'Error ending call: $e');
      }
    }
  }

  void _onSwitchCamera() {
    _engine.switchCamera();
    setState(() {
      _isFrontCamera = !_isFrontCamera;
    });
  }

  @override
  void dispose() {
    super.dispose();
    _dispose();
  }

  Future<void> _dispose() async {
    // Leave the channel
    await _engine.leaveChannel();
    // Release resources
    await _engine.release();
  }

  // Build the UI to display local and remote videos
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'Live Broadcast',
          style: TextStyle(fontSize: 16),
        ),
        automaticallyImplyLeading: false,
      ),
      body: _initStatusLoading
          ? const Center(child: CircularProgressIndicator())
          : Stack(
              children: [
                Center(
                  child: AgoraVideoView(
                    controller: VideoViewController(
                      rtcEngine: _engine,
                      canvas: const VideoCanvas(uid: 0),
                    ),
                  ),
                ),

                // Control buttons
                Positioned(
                  bottom: 20,
                  left: 0,
                  right: 0,
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      RawMaterialButton(
                        onPressed: _isMuted? _onToggleMute: _onToggleShowMute,
                        shape: const CircleBorder(),
                        padding: const EdgeInsets.all(12),
                        fillColor: _isMuted ? Colors.red : Colors.green,
                        child: Icon(
                          _isMuted ? Icons.mic_off : Icons.mic,
                          color: Colors.white,
                        ),
                      ),
                      RawMaterialButton(
                        onPressed: _isVideoEnabled
                            ? _onToggleVideo
                            : _onToggleShowVideo,
                        shape: const CircleBorder(),
                        padding: const EdgeInsets.all(12),
                        fillColor: _isVideoEnabled ? Colors.green : Colors.red,
                        child: Icon(
                          _isVideoEnabled ? Icons.videocam : Icons.videocam_off,
                          color: Colors.white,
                        ),
                      ),
                      RawMaterialButton(
                        onPressed: _onSwitchCamera,
                        shape: const CircleBorder(),
                        padding: const EdgeInsets.all(12),
                        fillColor: Colors.blue,
                        child: const Icon(
                          Icons.switch_camera,
                          color: Colors.white,
                        ),
                      ),
                      RawMaterialButton(
                        onPressed: _onEndCall,
                        shape: const CircleBorder(),
                        padding: const EdgeInsets.all(12),
                        fillColor: Colors.red,
                        child: const Icon(
                          Icons.call_end,
                          color: Colors.white,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
    );
  }
}
